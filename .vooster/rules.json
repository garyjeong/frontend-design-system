{
  "rules": [
    {
      "type": "prd",
      "content": "## Product Requirements Document (PRD)\n\n### 1. Introduction\n\nThis document outlines the requirements for a design system intended for individual front-end developers. The goal is to enable developers with limited design expertise to rapidly create stylish and professional websites and applications.\n\n### 2. Goals\n\n*   Enable individual developers to create visually appealing websites/apps quickly.\n*   Improve development productivity through reusable components and templates.\n*   Provide a design system that is easy to use and customize.\n\n### 3. Target Audience\n\n*   Individual developers\n\n### 4. Use Cases\n\n*   Creating personal portfolio websites.\n*   Developing simple web applications.\n\n### 5. Features\n\n*   **UI Component Library:**\n    *   Buttons (primary, secondary, icon)\n    *   Form elements (text fields, dropdowns, checkboxes, radio buttons)\n    *   Navigation (menus, tabs, pagination)\n    *   Data display (tables, lists, cards)\n    *   Notifications (toasts, modals)\n    *   Avatars\n*   **Design Templates:**\n    *   Page layouts\n    *   Common UI patterns\n\n### 6. Design and Style\n\n*   The design system will draw inspiration from Material Design and Ant Design.\n*   Emphasis on a modern and clean aesthetic.\n*   Focus on ease of customization to allow developers to express their personal style.\n\n### 7. Performance\n\n*   Components should be lightweight and performant.\n*   Optimized for fast loading times.\n\n### 8. Technology\n\n*   The design system will be implemented using web technologies (HTML, CSS, JavaScript).\n*   Consider using a component library framework (e.g., React, Vue, Angular) for enhanced reusability and maintainability.\n\n### 9. Future Considerations\n\n*   Expand the component library with more advanced components.\n*   Develop a theme system for easy customization.\n*   Provide integrations with popular development tools.\n\n### 10. Success Metrics\n\n*   Adoption rate among individual developers.\n*   Number of websites/apps built using the design system.\n*   Positive feedback from users.\n\n### 11. Roadmap\n\n*   **Phase 1:** Develop core UI components and style guide.\n*   **Phase 2:** Create design templates for common use cases.\n*   **Phase 3:** Add advanced components and theme system.",
      "writedAt": "2025-12-03T10:36:55.356Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 본 프로젝트는 프론트엔드 개발자들이 디자인 전문 지식 없이도 빠르고 세련된 웹사이트 및 애플리케이션을 구축할 수 있도록 지원하는 디자인 시스템을 구축하는 것을 목표로 합니다. ReactJS와 NextJS를 활용하여 재사용 가능한 UI 컴포넌트 라이브러리와 디자인 템플릿을 제공하여 개발 생산성을 향상시키고 사용자 정의를 용이하게 합니다.\n- **Core Technology Stack**: ReactJS, NextJS\n- **Key Technical Objectives**: 고성능, 빠른 로딩 시간, 쉬운 사용자 정의 및 확장성을 목표로 합니다.\n- **Critical Technical Assumptions**: 개발자들이 기본적인 웹 개발 지식(HTML, CSS, JavaScript)을 가지고 있으며, 컴포넌트 기반 개발 방식에 익숙하다고 가정합니다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Framework         | NextJS                      | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG)을 지원하여 초기 로딩 속도 향상 및 SEO 최적화에 유리합니다. |\n| UI Library        | ReactJS                     | 컴포넌트 기반 아키텍처를 통해 재사용 가능한 UI 컴포넌트 개발에 용이하며, 활발한 커뮤니티 지원 및 다양한 라이브러리 활용이 가능합니다. |\n| Styling           | Styled Components           | CSS-in-JS 방식을 통해 컴포넌트 스타일을 캡슐화하고, 동적인 스타일링 및 테마 관리를 용이하게 합니다. |\n| State Management  | React Context API           | 비교적 간단한 상태 관리를 위해 React 내장 Context API를 활용합니다.  더 복잡한 상태 관리가 필요한 경우 Redux 또는 Zustand를 고려할 수 있습니다. |\n| Component Library | Material UI / Ant Design (Customized) | Material UI 또는 Ant Design을 기반으로 시작하여 필요한 컴포넌트를 커스터마이징하여 사용합니다. 디자인 시스템의 일관성을 유지하면서 개발 시간을 단축할 수 있습니다. |\n| Icons             | React Icons                 | 다양한 아이콘 라이브러리를 쉽게 사용할 수 있도록 지원합니다. |\n| Testing           | Jest, React Testing Library | 컴포넌트의 기능 및 UI를 테스트하기 위한 도구입니다. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (NextJS Application)**\n    - UI Component Library: 재사용 가능한 React 컴포넌트 (버튼, 폼 요소, 네비게이션, 데이터 디스플레이, 알림, 아바타 등)\n    - Design Templates: 페이지 레이아웃 및 일반적인 UI 패턴 템플릿\n    - Routing: NextJS의 파일 기반 라우팅 시스템을 사용하여 페이지 간 이동 관리\n    - State Management: React Context API를 사용하여 컴포넌트 간 상태 공유 및 관리\n- **Styling (Styled Components)**\n    - Theme Provider: 디자인 시스템의 테마를 관리하고 컴포넌트에 적용\n    - Global Styles: 전체 애플리케이션에 적용되는 기본 스타일 설정\n    - Component Styles: 각 컴포넌트의 스타일 정의 및 관리\n- **Deployment (Vercel / Netlify)**\n    - CI/CD Pipeline: 코드 변경 시 자동으로 빌드 및 배포\n    - Hosting: 애플리케이션을 호스팅하고 사용자에게 제공\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[사용자] --> B(NextJS Frontend);\n    B --> C{React Components};\n    C --> D[Styled Components];\n    D --> E((Theme Provider));\n    B --> F[Design Templates];\n    F --> C;\n    B --> G(Vercel / Netlify);\n```\n\n- **사용자 상호 작용**: 사용자는 NextJS 프론트엔드 애플리케이션과 상호 작용합니다.\n- **컴포넌트 렌더링**: NextJS는 React 컴포넌트를 렌더링하고, Styled Components를 통해 스타일을 적용합니다.\n- **테마 적용**: Theme Provider는 디자인 시스템의 테마를 컴포넌트에 적용합니다.\n- **배포**: Vercel 또는 Netlify를 통해 애플리케이션이 배포됩니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 컴포넌트를 기능별로 분리합니다 (예: `components/buttons`, `components/forms`, `components/navigation`).\n- **Layer-Based Architecture**: 컴포넌트, 스타일, 데이터 로직을 분리합니다.\n- **Feature-Based Modules**: 페이지 또는 특정 기능에 관련된 컴포넌트와 로직을 함께 그룹화합니다 (예: `pages/portfolio`, `components/portfolio`).\n- **Shared Components**: 공통으로 사용되는 유틸리티, 타입, 재사용 가능한 컴포넌트는 `shared` 디렉토리에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/              # 재사용 가능한 React 컴포넌트\n│   ├── buttons/           # 버튼 컴포넌트\n│   │   ├── Button.jsx\n│   │   ├── Button.module.css\n│   │   └── ...\n│   ├── forms/             # 폼 요소 컴포넌트\n│   │   ├── TextField.jsx\n│   │   ├── Dropdown.jsx\n│   │   └── ...\n│   ├── navigation/        # 네비게이션 컴포넌트\n│   │   ├── Menu.jsx\n│   │   ├── Tabs.jsx\n│   │   └── ...\n│   └── ...\n├── pages/                 # NextJS 페이지\n│   ├── index.jsx          # 메인 페이지\n│   ├── portfolio.jsx      # 포트폴리오 페이지\n│   └── ...\n├── styles/                # 전역 스타일 및 테마\n│   ├── globals.css        # 전역 CSS 스타일\n│   ├── theme.js           # 테마 정의\n│   └── ...\n├── public/                # 정적 파일 (이미지, 폰트 등)\n│   ├── images/\n│   ├── fonts/\n│   └── ...\n├── utils/                 # 유틸리티 함수\n│   ├── api.js           # API 호출 함수\n│   ├── helpers.js       # 헬퍼 함수\n│   └── ...\n├── .eslintrc.js           # ESLint 설정\n├── next.config.js         # NextJS 설정\n└── package.json           # 프로젝트 의존성 및 스크립트\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: NextJS의 `getServerSideProps` 또는 `getStaticProps`를 사용하여 서버에서 데이터를 가져와 컴포넌트에 전달합니다.\n- **Database Interaction**: 필요에 따라 API를 통해 데이터베이스와 상호 작용합니다. (본 프로젝트에서는 데이터베이스가 필수는 아님)\n- **External Service Integration**: 필요에 따라 외부 API를 호출하여 데이터를 가져옵니다. (예: 이미지 CDN)\n- **Real-time Communication**: 본 프로젝트에서는 실시간 통신이 필요하지 않습니다.\n- **Data Synchronization**: 데이터 동기화는 필요에 따라 API 호출을 통해 수행합니다.\n\n## 4. Performance & Optimization Strategy\n- **Code Splitting**: NextJS의 자동 코드 분할 기능을 활용하여 초기 로딩 시간을 단축합니다.\n- **Image Optimization**: 이미지 CDN을 사용하여 이미지 크기를 최적화하고, Lazy Loading을 적용하여 초기 로딩 시 불필요한 이미지 로딩을 지연시킵니다.\n- **Caching**: `getStaticProps`를 사용하여 정적 데이터를 캐싱하고, `getServerSideProps`를 사용하여 서버 사이드 렌더링된 페이지를 캐싱합니다.\n- **Memoization**: React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: NextJS 프로젝트 설정, 기본 폴더 구조 구축, ESLint 설정\n- **Essential Features**: 기본 UI 컴포넌트 (버튼, 텍스트 필드, 드롭다운), 기본 페이지 레이아웃, 스타일 가이드 정의\n- **Basic Security**: 기본적인 보안 설정 (CORS, XSS 방지)\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축 (Vercel / Netlify)\n- **Timeline**: 4주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 고급 UI 컴포넌트 (테이블, 리스트, 카드, 알림, 아바타), 디자인 템플릿 추가, 테마 시스템 구현\n- **Performance Optimization**: 이미지 최적화, 코드 분할, 캐싱 전략 적용\n- **Enhanced Security**: 고급 보안 기능 구현 (CSRF 방지, Rate Limiting)\n- **Monitoring Implementation**: 오류 로깅 및 성능 모니터링 설정\n- **Timeline**: 6주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: ReactJS 및 NextJS에 대한 숙련도 부족, Styled Components 사용 시 성능 문제 발생 가능성\n- **Performance Risks**: 컴포넌트 렌더링 성능 저하, 초기 로딩 시간 증가\n- **Security Risks**: XSS, CSRF 공격에 취약할 가능성\n- **Integration Risks**: 외부 API 의존성으로 인한 장애 발생 가능성\n- **Mitigation Strategies**:\n    - ReactJS 및 NextJS 학습 및 경험 축적\n    - Styled Components 사용 시 성능 테스트 및 최적화\n    - 보안 취약점 분석 및 방어 대책 마련\n    - 외부 API 장애 대비를 위한 예외 처리 및 대체 API 구현\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연, 예상치 못한 기술적 문제 발생\n- **Resource Risks**: 개발 인력 부족, 기술 전문가 확보 어려움\n- **Quality Risks**: 코드 품질 저하, 테스트 부족\n- **Deployment Risks**: 배포 환경 문제 발생, 배포 실패\n- **Contingency Plans**:\n    - 개발 일정 지연 시 기능 축소 또는 우선순위 조정\n    - 개발 인력 부족 시 추가 인력 확보 또는 외부 전문가 활용\n    - 코드 품질 확보를 위한 코드 리뷰 및 테스트 강화\n    - 배포 환경 문제 발생 시 롤백 전략 마련\n",
      "writedAt": "2025-12-03T10:36:55.356Z"
    },
    {
      "type": "guideline",
      "content": "# Project Code Guidelines\n\n## 1. Project Overview\n\nThis project involves building a design system for individual front-end developers using ReactJS and NextJS. The system provides reusable UI components and design templates to enhance development productivity and ease customization.\n\nKey architectural decisions:\n\n*   **Framework**: NextJS for server-side rendering (SSR) and static site generation (SSG).\n*   **UI Library**: ReactJS for component-based architecture.\n*   **Styling**: Styled Components for CSS-in-JS.\n*   **State Management**: React Context API for simple state management.\n\n## 2. Core Principles\n\n*   **Single Responsibility**: Each component/function should have one specific job.\n*   **Reusability**: Components should be designed to be reused across the application.\n*   **Maintainability**: Code should be easy to understand, modify, and debug.\n*   **Performance**: Optimize for fast loading times and efficient rendering.\n*   **Testability**: Code should be written in a way that makes it easy to test.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. JavaScript (React/NextJS)\n\n#### File Organization and Directory Structure\n\n*   Follow the domain-driven organization strategy as outlined in the TRD.\n*   Component files should be placed in relevant directories within the `components` folder.\n*   Page files should reside in the `pages` directory.\n*   Utility functions and helper files should be in the `utils` directory.\n*   Styles (global and component-specific) should be in the `styles` directory.\n\n#### Import/Dependency Management\n\n*   Use absolute imports for internal modules (`@/components/Button` instead of relative paths like `../../components/Button`). Configure `@` alias in `jsconfig.json` or `tsconfig.json`.\n*   Group imports by origin (e.g., node modules, internal modules, styles).\n*   Order imports alphabetically within each group.\n*   Install dependencies using `npm install` or `yarn add`.\n*   Use `devDependencies` for testing libraries and build tools.\n\n#### Error Handling Patterns\n\n*   Use `try...catch` blocks for handling potential errors in asynchronous operations (e.g., API calls).\n*   Implement error boundaries for catching errors in React component trees.\n*   Log errors to the console or a dedicated logging service for debugging.\n*   Display user-friendly error messages to the user.\n\n### 3.2. CSS (Styled Components)\n\n#### File Organization\n\n*   Component-specific styles should be defined within the component file using Styled Components.\n*   Global styles should be defined in `styles/globals.css` or using Styled Components' `createGlobalStyle`.\n*   Theme variables should be defined in `styles/theme.js`.\n\n#### Naming Conventions\n\n*   Use camelCase for Styled Components variable names (e.g., `StyledButton`).\n*   Use semantic class names in global styles (e.g., `.button--primary`).\n\n#### Best Practices\n\n*   Use theme variables for consistent styling across the application.\n*   Avoid using inline styles directly in components.\n*   Use media queries for responsive design.\n*   Use `attrs` to pass props to styled components.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Naming Conventions**:\n    *   Variables: camelCase (e.g., `userName`, `productPrice`).\n    *   Functions: camelCase (e.g., `getUserData`, `calculateTotal`).\n    *   Components: PascalCase (e.g., `Button`, `TextField`).\n    *   Files: PascalCase or camelCase depending on the content (e.g., `Button.jsx`, `api.js`).\n    *   Rationale: Consistent naming improves readability and maintainability.\n*   **Component Structure**:\n    *   Functional components with hooks are preferred.\n    *   Separate UI logic from data fetching/processing logic.\n    *   Use prop types for type checking.\n    *   Rationale: Functional components are simpler to reason about and test. Separation of concerns improves maintainability.\n*   **State Management**:\n    *   Use React Context API for simple, localized state management.\n    *   Consider Redux or Zustand for more complex global state management scenarios (if needed, but avoid over-engineering).\n    *   Rationale: Context API is sufficient for this project's scope.\n*   **Styling**:\n    *   Use Styled Components for component-level styling.\n    *   Use theme variables for consistent styling.\n    *   Avoid inline styles.\n    *   Rationale: Styled Components encapsulate styles and make them easier to manage.\n*   **Error Handling**:\n    *   Use `try...catch` blocks for error handling in asynchronous operations.\n    *   Implement error boundaries for React components.\n    *   Log errors to the console or a logging service.\n    *   Rationale: Proper error handling prevents application crashes and provides useful debugging information.\n*   **Code Formatting**:\n    *   Use Prettier for code formatting.\n    *   Configure ESLint for code linting.\n    *   Rationale: Consistent code formatting improves readability and reduces merge conflicts.\n\n### MUST NOT Do:\n\n*   **Direct DOM Manipulation**:\n    *   Rationale: React manages the DOM, direct manipulation can lead to inconsistencies and unexpected behavior.\n*   **Mutating State Directly**:\n    *   Rationale: React relies on immutability to detect changes and trigger re-renders.\n*   **Ignoring ESLint/Prettier Warnings/Errors**:\n    *   Rationale: ESLint and Prettier help enforce code style and prevent common errors.\n*   **Over-engineering State Management**:\n    *   Rationale: Start with React Context, and only move to Redux/Zustand if absolutely necessary. Avoid unnecessary complexity.\n*   **Leaving Console Logs in Production Code**:\n    *   Rationale: Console logs can expose sensitive information and impact performance.\n*   **Writing Large, Complex Components**:\n    *   Rationale: Large components are difficult to understand, test, and maintain. Break down complex components into smaller, reusable components.\n*   **Using `any` Type**:\n    *   Rationale: `any` defeats the purpose of TypeScript. Use specific types or interfaces whenever possible.\n*   **Defining Complex State Management Pattern**:\n    *   Rationale: Keep state management simple. Avoid complex patterns unless absolutely necessary.\n*   **Making huge, multi responsibility module in single file**:\n    *   Rationale: Follow single responsibility principle. Each module must have a single responsibility.\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n*   **Atomic Design Principles**: Consider using Atomic Design principles (Atoms, Molecules, Organisms, Templates, Pages) to structure components.\n*   **Directory Structure**: Follow the directory structure outlined in the TRD.\n*   **Component Composition**: Build complex components by composing smaller, reusable components.\n*   **Props**: Use props to pass data and functionality to components.\n*   **Naming**: Use clear and descriptive names for components and files.\n\n### 5.2. Data Flow Patterns\n\n*   **Top-Down Data Flow**: Data flows from parent components to child components via props.\n*   **Event Handling**: Child components can trigger events that are handled by parent components.\n*   **Context API**: Use Context API for sharing data between components that are not directly related.\n*   **API Calls**: Use `getServerSideProps` or `getStaticProps` in NextJS to fetch data from APIs on the server-side.\n\n### 5.3. State Management Conventions\n\n*   **Local Component State**: Use `useState` hook for managing local component state.\n*   **Context API**: Use Context API for sharing state between components.\n*   **Reducers (if needed)**: If using Redux or Zustand, use reducers to update state in a predictable manner.\n*   **Immutability**: Always update state immutably.\n\n### 5.4. API Design Standards\n\n*   **RESTful APIs**: Design APIs following RESTful principles.\n*   **Naming Conventions**: Use clear and descriptive names for API endpoints.\n*   **Data Format**: Use JSON for data exchange.\n*   **Error Handling**: Return appropriate HTTP status codes for errors.\n*   **Authentication**: Implement authentication and authorization for secure APIs.\n\n## Example Code Snippets\n\n### React Component\n\n```jsx\n// MUST: Example of a functional React component with props and styling\n// This component displays a button with a label and handles click events.\nimport React from 'react';\nimport styled from 'styled-components';\n\nconst StyledButton = styled.button`\n  background-color: ${props => props.theme.primaryColor};\n  color: white;\n  padding: 10px 20px;\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n\n  &:hover {\n    opacity: 0.8;\n  }\n`;\n\nconst Button = ({ label, onClick }) => {\n  return (\n    <StyledButton onClick={onClick}>{label}</StyledButton>\n  );\n};\n\nexport default Button;\n```\n\n```jsx\n// MUST NOT: Example of a component with inline styles and direct DOM manipulation\n// Inline styles are difficult to manage and maintain. Direct DOM manipulation bypasses React's rendering process.\nimport React from 'react';\n\nconst BadButton = ({ label, onClick }) => {\n  return (\n    <button style={{ backgroundColor: 'red', color: 'white' }} onClick={() => {\n      document.getElementById('my-element').innerHTML = 'Clicked!';\n      onClick();\n    }}>\n      {label}\n    </button>\n  );\n};\n\nexport default BadButton;\n```\n\n### Styled Components\n\n```javascript\n// MUST: Example of using Styled Components with theme variables\n// Theme variables provide a consistent look and feel across the application.\nimport styled from 'styled-components';\n\nexport const StyledTitle = styled.h1`\n  font-size: 2em;\n  color: ${props => props.theme.textColor};\n`;\n```\n\n### Error Handling\n\n```javascript\n// MUST: Example of using try...catch for error handling in an API call\n// This ensures that errors are caught and handled gracefully.\nasync function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    // Display user-friendly error message\n    return null;\n  }\n}\n```\n\n### Context API\n\n```jsx\n// MUST: Example of using Context API for state management\n// This allows sharing state between components without prop drilling.\nimport React, { createContext, useState, useContext } from 'react';\n\nconst ThemeContext = createContext();\n\nexport const ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = () => useContext(ThemeContext);\n```\n",
      "writedAt": "2025-12-03T10:36:55.356Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-12-03T10:36:55.356Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-12-03T10:36:55.356Z"
    }
  ]
}